<script module lang="ts">
  import { pythonExecutor } from '@worker/executor';
  import type { Script, ScriptExecution } from '@config/types.js';
  import { select, clearOtherSelections, getSelection } from '@core/state/workspace.svelte';
  import { activeFileRequirements, files as uploadedFiles } from '@plugins/required-files/store.svelte';
  import { addResult } from '@plugins/results/store.svelte';
  import { registerSelectionResolver } from '@utils/breadcrumbs.ts';

  export const availableScripts = $state<Script[]>([]);
  export const executions = $state<Record<string, ScriptExecution>>({});
  // Note: Don't pre-initialize executions - they should be created on-demand when scripts run
  // This ensures proper dependency checking and prevents showing "Ready" for scripts with unmet dependencies

  // Helper function to determine file type from filename
  function getFileType(filename: string): string {
    const ext = filename.toLowerCase().split('.').pop() || '';
    const typeMap: Record<string, string> = {
      'html': 'HTML',
      'htm': 'HTML',
      'csv': 'CSV',
      'json': 'JSON',
      'txt': 'Text',
      'md': 'Markdown',
      'png': 'Image',
      'jpg': 'Image',
      'jpeg': 'Image',
      'gif': 'Image',
      'svg': 'Image',
      'pdf': 'PDF',
      'parquet': 'Parquet',
      'xlsx': 'Excel',
      'xls': 'Excel'
    };
    return typeMap[ext] || 'Unknown';
  }

  export async function startExecution(scriptId: string) {
    const script = availableScripts.find(s => s.id === scriptId); if (!script) throw new Error(`Script ${scriptId} not found`);
    const base: ScriptExecution = { id: `exec_${scriptId}_${Date.now()}`, scriptId, status: 'running', lastRun: new Date().toISOString() };
    executions[scriptId] = base;
    try {
      // Gather uploaded dependency files using new fileRequirements format
      const dataFiles = (script.fileRequirements || [])
        .filter(req => req.source === 'uploaded' || !req.source) // default to uploaded if not specified
        .map(req => {
          const uploaded = uploadedFiles[req.filename];
          if (uploaded?.file) {
            return { file: uploaded.file, filename: req.filename };
          }
          return null; // missing dependency; silently skip (status UI will reflect waiting earlier)
        })
        .filter(Boolean) as { file: File; filename: string }[];

      const result = await pythonExecutor.executeScript(
        { id: script.id, content: script.content, title: script.title },
        { timeout:86400000, dataFiles, onStatusUpdate: (status) => { if (executions[scriptId]) executions[scriptId].metrics = { ...executions[scriptId].metrics, status }; } }
      );
      const generatedFiles = result.modifiedFiles || [];
      const end = new Date().toISOString();
      
      // Add generated files to Results plugin
      for (const file of generatedFiles) {
        addResult({
          filename: file.name,
          fileType: getFileType(file.name),
          fileSize: file.data.length,
          content: file.data,
          createdAt: end,
          scriptId: script.id,
          description: `Generated by ${script.title}`,
          pyodidePath: file.path
        });
      }
      
      executions[scriptId] = { ...base, status: result.success ? 'completed':'error', executionTime: `${result.executionTime}ms`, output: result.output, error: result.error, lastRun: end, metrics: { executionTime: `${result.executionTime}ms`, lastRun: end, outputLines: result.output?.split('\n').length || 0, errorCount: result.error ? 1:0, filesGenerated: generatedFiles.length } };
    } catch (e) {
      executions[scriptId] = { ...base, status: 'error', error: e instanceof Error? e.message:'Unknown error', lastRun: new Date().toISOString() };
      throw e;
    }
  }
  export function selectScript(id: string | null) { clearOtherSelections('script'); select('script', id); }
  export function getScript(id: string) { return availableScripts.find(s => s.id === id); }
  export function getExecution(id: string) { return executions[id]; }
  export function getExecutionStatus(id: string): "ready" | "running" | "completed" | "error" { 
    return executions[id]?.status || 'ready'; 
  }
  export function isScriptSelected(id: string) { return getSelection('script') === id; }

  // Configuration management functions
  export function clearScripts() {
    // Clear all scripts and executions
    availableScripts.length = 0;
    Object.keys(executions).forEach(key => delete executions[key]);
    // Clear any script selections
    clearOtherSelections('script');
  }

  export function loadScripts(newScripts: Script[]) {
    // Clear existing state
    clearScripts();
    
    // Update available scripts
    availableScripts.push(...newScripts);
    
    // Note: Don't pre-initialize executions for new scripts.
    // Executions are created on-demand when scripts are actually run.
    // This allows proper dependency checking to determine if scripts show "Waiting" or "Ready"
  }

  export function getAvailableScripts() {
    return availableScripts;
  }

  // Register breadcrumb resolver for scripts
  registerSelectionResolver('script', {
    getDisplayName: (id: string) => {
      const script = availableScripts.find(s => s.id === id);
      return script ? script.title : null;
    },
    getStatus: (id: string) => {
      return getExecutionStatus(id);
    }
  });
</script>
